# 09 — Data Schema Mapping

> **Status**: Complete
> **Created**: 2026-02-24
> **Purpose**: Map every field in the current `data.json` POS snapshot to normalized database tables and TypeScript types for the Laravel + scheduling engine platform.

---

## Table of Contents

1. [Current data.json Structure](#current-datajson-structure)
2. [Data Volume](#data-volume)
3. [Field-by-Field Mapping](#field-by-field-mapping)
4. [Normalized Database Schema](#normalized-database-schema)
5. [TypeScript Type Definitions](#typescript-type-definitions)
6. [Migration Notes](#migration-notes)

---

## Current data.json Structure

`data.json` is a ~1.3MB pre-computed POS snapshot generated by Python scripts from Square transaction exports and DoorDash CSV data. It contains 19 top-level keys organized into metadata, aggregated metrics, daily actuals, employee rosters, templates, and integration summaries.

### Top-Level Keys

| Key | Type | Description |
|-----|------|-------------|
| `generated_on` | `string` | ISO date when the snapshot was built (`"2026-02-20"`) |
| `months` | `string[]` | Ordered list of 44 month keys (`"2022-07"` through `"2026-02"`) |
| `month_labels` | `Record<MonthKey, string>` | Human-readable labels (`"Jul 2022"`) |
| `month_status` | `Record<MonthKey, string>` | Data source status: `"actual"` for all months |
| `source_for_month` | `Record<MonthKey, string>` | Source file mapping (`"july2022"`, `"august2022"`, ...) |
| `weekday_order` | `string[]` | `["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]` |
| `monthly` | `Record<LocationCode, Record<MonthKey, MonthlyMetrics>>` | Monthly aggregated metrics per location |
| `weekday_profile` | `Record<LocationCode, Record<MonthKey, Record<Weekday, WeekdayMetrics>>>` | Weekday averages per location per month |
| `hourly_profile` | `Record<LocationCode, Record<MonthKey, HourlyMetrics[]>>` | 24-hour revenue/labor curves per location per month |
| `monday_scenario` | `Record<LocationCode, Record<MonthKey, MondayScenario>>` | Monday revenue projections based on Tuesday baseline |
| `monday_labor` | `Record<LocationCode, Record<MonthKey, number>>` | Estimated weekly Monday labor cost |
| `daily_actual` | `Record<LocationCode, DailyActual[]>` | Daily transaction-level actuals (EP: 1,049 rows, NL: 474 rows) |
| `daily_actual_by_date` | `Record<LocationCode, Record<ISODate, DailyActual>>` | Same data indexed by date for O(1) lookup |
| `calendar` | `Record<MonthKey, CalendarInfo>` | Weekday counts and operating day totals per month |
| `employees` | `Record<LocationCode|"BOTH", string[]>` | Employee name rosters from Square |
| `plan_templates` | `Record<PlanKey, PlanTemplate>` | Staffing plan templates (6-day and 7-day) |
| `manager_assumptions` | `ManagerAssumptions` | Manager pay rate and weekly hours |
| `doordash_integration` | `DoorDashIntegration` | DoorDash data pipeline metadata and per-location summaries |
| `notes` | `string[]` | Human-readable notes about the dataset |

---

## Data Volume

| Metric | Value |
|--------|-------|
| File size | ~1.3 MB |
| Time span | Jul 2022 — Feb 2026 (44 months) |
| Locations | 2 (EP = East Passyunk, NL = Northern Liberties) |
| Daily actuals (EP) | 1,049 rows |
| Daily actuals (NL) | 474 rows |
| Employees (EP) | 43 |
| Employees (NL) | 24 |
| Employees (shared) | 13 |
| Hourly profile entries | 24 per month per location (1,056 per location) |
| Weekday profile entries | 7 per month per location (308 per location) |
| DoorDash rows processed | 3,699 |

---

## Field-by-Field Mapping

### `monthly[location][monthKey]` → `monthly_metrics` table

Pre-computed monthly aggregates. In the new system, these are computed on-demand from daily actuals by the scheduling engine or cached as materialized views.

| Source Field | Type | Example | Normalized Field | Notes |
|-------------|------|---------|-----------------|-------|
| `days` | `number` | `31` | Computed from `daily_actuals` count | Not stored; derived |
| `revenue` | `number` | `42531.89` | `SUM(daily_actuals.revenue)` | POS in-store revenue |
| `store_labor` | `number` | `12847.22` | `SUM(daily_actuals.store_labor)` | Floor labor only, excludes production |
| `doordash_net_component` | `number` | `9009.40` | `SUM(daily_actuals.delivery_net)` | Net delivery revenue (after commissions) |
| `gross_profit_72` | `number` | `17875.34` | **Computed**: `revenue * (1 - cogsPct/100) - store_labor` | Currently hardcoded 0.72; must use tenant COGS% |
| `labor_pct` | `number` | `30.21` | **Computed**: `store_labor / revenue * 100` | Derived metric |
| `avg_daily_revenue` | `number` | `1372.00` | **Computed**: `revenue / operating_days` | Derived |
| `avg_daily_labor` | `number` | `414.43` | **Computed**: `store_labor / operating_days` | Derived |
| `avg_daily_doordash_net` | `number` | `290.63` | **Computed**: `doordash_net / operating_days` | Derived |
| `avg_daily_gp_72` | `number` | `576.62` | **Computed** | Derived |

**Decision**: Monthly metrics are **not stored as a separate table**. They are computed by the scheduling engine from daily actuals. For performance, Laravel can cache these as a materialized view or Redis cache keyed by `(tenant_id, location_id, month_key)`.

### `weekday_profile[location][monthKey][weekday]` → computed aggregation

Average metrics for each weekday within a month. Used as baseline expectations for shift planning.

| Source Field | Type | Example | Normalized Field | Notes |
|-------------|------|---------|-----------------|-------|
| `days` | `number` | `5` | Count of matching weekdays in the month | Derived from calendar |
| `avg_revenue` | `number` | `2891.43` | `AVG(daily_actuals.revenue) WHERE weekday = X` | Computed |
| `avg_labor` | `number` | `680.11` | `AVG(daily_actuals.store_labor) WHERE weekday = X` | Computed |
| `avg_doordash_net` | `number` | `412.30` | `AVG(daily_actuals.delivery_net) WHERE weekday = X` | Computed |
| `avg_gp_72` | `number` | `1402.12` | Computed with tenant COGS% | Computed |
| `labor_pct` | `number` | `23.52` | Computed | Computed |

**Decision**: **Computed on-demand** by the scheduling engine's `expectedDayProfile()` equivalent. No separate table needed.

### `hourly_profile[location][monthKey]` → computed aggregation

24-entry array (hours 0-23) of average revenue/labor per hour. Used for hourly sales curve charts.

| Source Field | Type | Example | Notes |
|-------------|------|---------|-------|
| `hour` | `number` | `14` | Hour of day (0-23) |
| `avg_revenue` | `number` | `523.11` | Average hourly revenue |
| `avg_labor` | `number` | `89.22` | Average hourly labor |
| `avg_doordash_net` | `number` | `35.10` | Average hourly delivery net |
| `avg_gp_72` | `number` | `287.52` | Computed |

**Decision**: Requires **hourly transaction data** in the daily_actuals table, or a separate `hourly_actuals` table. Currently computed by the Python pipeline from raw Square hourly exports. In the new system, the POS adapter must pull hourly-grain data.

### `monday_scenario[location][monthKey]` → computed from weekday_profile

Monday revenue projections based on Tuesday baseline at three confidence levels.

| Source Field | Type | Example | Notes |
|-------------|------|---------|-------|
| `tuesday_baseline` | `number` | `2891.43` | Tuesday avg revenue for that month |
| `low_55pct` | `number` | `1590.29` | `tuesday_baseline * 0.55` |
| `base_65pct` | `number` | `1879.43` | `tuesday_baseline * 0.65` |
| `high_75pct` | `number` | `2168.57` | `tuesday_baseline * 0.75` |

**Decision**: **Computed by the scheduling engine** from weekday profile data using configurable Monday factors (currently 55/65/75%). No storage needed.

### `monday_labor[location][monthKey]` → computed

| Source Field | Type | Example | Notes |
|-------------|------|---------|-------|
| (value) | `number` | `411.0` | Estimated weekly Monday labor cost |

**Decision**: **Computed** from staffing template for Monday shifts and pay rates.

### `daily_actual[location]` → `daily_actuals` table (PRIMARY SOURCE)

This is the **core transactional data** — everything else is derived from it. This is what the POS adapter populates.

| Source Field | Type | Example | DB Column | DB Type | Notes |
|-------------|------|---------|-----------|---------|-------|
| `date` | `string` | `"2025-07-15"` | `date` | `DATE` | **Primary key** (with tenant+location) |
| `month_key` | `string` | `"2025-07"` | — | — | Derived from `date`; not stored |
| `month_label` | `string` | `"Jul 2025"` | — | — | Derived; not stored |
| `weekday` | `string` | `"Tue"` | — | — | Derived from `date`; not stored |
| `transactions` | `number` | `341` | `transactions` | `INT UNSIGNED` | POS transaction count |
| `revenue` | `number` | `5324.33` | `revenue` | `DECIMAL(10,2)` | POS in-store gross revenue |
| `store_labor` | `number` | `768.46` | `store_labor` | `DECIMAL(10,2)` | Floor labor cost (from POS timecards) |
| `gross_profit_72` | `number` | `3065.06` | — | — | **Not stored.** Computed as `revenue * (1 - cogsPct/100) - store_labor` |
| `labor_pct` | `number` | `14.43` | — | — | **Not stored.** Computed as `store_labor / revenue * 100` |
| `doordash_net` | `number` | `0.0` | `delivery_net` | `DECIMAL(10,2)` | Net delivery revenue. Renamed for POS-agnostic schema. |

**Additional columns for normalized schema** (not in current data.json):

| Column | Type | Source | Notes |
|--------|------|--------|-------|
| `id` | `BIGINT UNSIGNED` | Auto | Primary key |
| `tenant_id` | `BIGINT UNSIGNED` | Tenant context | Multi-tenant scoping |
| `location_id` | `BIGINT UNSIGNED` | FK to `locations` | Replaces string location codes |
| `delivery_source` | `VARCHAR(50)` | Adapter | `'doordash'`, `'ubereats'`, `'grubhub'`, `null` |
| `delivery_gross` | `DECIMAL(10,2)` | Delivery adapter | Gross delivery revenue (before commissions) |
| `delivery_commission` | `DECIMAL(10,2)` | Delivery adapter | Commission amount |
| `source` | `VARCHAR(50)` | Adapter | `'square'`, `'clover'`, `'toast'`, etc. |
| `synced_at` | `TIMESTAMP` | POS sync | When data was last pulled from POS |

### `daily_actual_by_date[location][date]` → same `daily_actuals` table

Duplicate of `daily_actual` indexed by date for O(1) lookup. In the database, this is just a query with a `WHERE date = ?` on the indexed `date` column. **No separate storage needed.**

### `calendar[monthKey]` → computed

| Source Field | Type | Example | Notes |
|-------------|------|---------|-------|
| `weekday_counts` | `Record<Weekday, number>` | `{"Mon": 4, "Tue": 5, ...}` | Computed from calendar math |
| `mondays` | `number` | `4` | `weekday_counts.Mon` |
| `operating_days_6` | `number` | `27` | Sum of Tue-Sun counts |

**Decision**: **Pure calendar math**, computed by the scheduling engine. No storage.

### `employees[location]` → `employees` table

| Source Field | Type | Example | DB Column | Notes |
|-------------|------|---------|-----------|-------|
| (array entry) | `string` | `"AJ Williams"` | `name` | Currently just names; needs full employee records |

**Current data is minimal** — just string arrays of names from Square. The normalized schema needs much more:

| Column | Type | Notes |
|--------|------|-------|
| `id` | `BIGINT UNSIGNED` | Primary key |
| `tenant_id` | `BIGINT UNSIGNED` | Multi-tenant scoping |
| `location_id` | `BIGINT UNSIGNED` | Primary location (nullable for multi-location) |
| `name` | `VARCHAR(255)` | Display name |
| `email` | `VARCHAR(255)` | For notifications and login |
| `phone` | `VARCHAR(20)` | Optional |
| `role_id` | `BIGINT UNSIGNED` | FK to `roles` (spatie/laravel-permission) |
| `pay_rate` | `DECIMAL(8,2)` | Hourly pay rate |
| `certifications` | `JSON` | `["servsafe_manager", "food_handler"]` etc. |
| `certification_expiry` | `JSON` | `{"servsafe_manager": "2027-03-15"}` |
| `square_employee_id` | `VARCHAR(100)` | POS adapter sync key |
| `availability` | `JSON` | Weekly availability preferences |
| `hire_date` | `DATE` | For seniority-based scheduling |
| `status` | `ENUM('active','inactive','terminated')` | Employment status |
| `created_at` / `updated_at` | `TIMESTAMP` | Laravel timestamps |

### `plan_templates` → `schedule_templates` table

Current structure is narrative (string descriptions), not machine-readable slot definitions. The `staffing-planner.js` has a separate `DEFAULT_BUSINESS_WEEKLY_TEMPLATE` with actual slot data.

| Source Key | Current Value | Notes |
|-----------|--------------|-------|
| `current_6_day.ep["Tue-Thu"]` | `["1 Manager Day", "2 Close Core (1 Key Lead + 1 Scooper)"]` | Human-readable, not structured |
| `current_6_day.ep["Fri"]` | `["Tue-Thu template + 1 Lead Day"]` | References other templates |
| `current_6_day.ep["Sat-Sun"]` | `["Fri template + 1 Peak Swing (summer)"]` | Seasonal reference |
| `open_7_day.winter_monday` | `["15:00-22:00 reduced-hours pilot", "2 closers..."]` | Mix of structured and narrative |

**Decision**: Templates in the new system use the structured format from `DEFAULT_BUSINESS_WEEKLY_TEMPLATE` in `staffing-planner.js` (start/end/role/headcount per slot), not the narrative format in `data.json`. The `data.json` templates are documentation, not machine data.

### `manager_assumptions` → tenant settings

| Source Field | Type | Value | Target |
|-------------|------|-------|--------|
| `hourly_rate` | `number` | `28.0` | `tenant_settings.pay_rates.manager` |
| `weekly_hours` | `number` | `40` | `tenant_settings.manager_weekly_hours` |
| `notes` | `string` | Explanatory text | Documentation only |

### `doordash_integration` → `delivery_sync_metadata` table

Pipeline metadata for DoorDash data processing. In the new system, this becomes delivery adapter sync logs.

| Source Field | Type | Notes |
|-------------|------|-------|
| `enabled` | `boolean` | Whether delivery integration is active |
| `hourly_file` | `string` | Source CSV path (pipeline artifact, not stored in DB) |
| `rows_total` | `number` | Audit metric: total rows processed |
| `rows_mapped_location` | `number` | Audit metric: rows with valid location |
| `rows_unmapped_location` | `number` | Audit metric: rows without location match |
| `rows_invalid_datetime` | `number` | Audit metric: rows with bad dates |
| `rows_supported_source_month` | `number` | Audit metric: rows in supported date range |
| `rows_applied_to_base_dates` | `number` | Audit metric: rows merged into daily actuals |
| `net_supported_total` | `number` | `$175,106.66` total DoorDash net revenue |
| `net_applied_total` | `number` | `$174,802.26` total applied to actuals |
| `summary_by_loc_source_month` | `nested` | Per-location, per-month order counts and net revenue |

**Decision**: Sync audit data goes into a `delivery_syncs` table. Per-day delivery revenue is merged into `daily_actuals.delivery_net`.

### Metadata fields → not stored

| Field | Decision |
|-------|----------|
| `generated_on` | Replaced by `synced_at` on individual records |
| `months` | Derived from `daily_actuals` date range |
| `month_labels` | Computed from date formatting |
| `month_status` | All data is `actual`; modeled data concept removed |
| `source_for_month` | Pipeline artifact; not needed in DB |
| `weekday_order` | Constant; defined in code |
| `notes` | Documentation; not stored |

---

## Normalized Database Schema

### Core Tables

```sql
-- Multi-tenant scoping via stancl/tenancy
-- All tables below implicitly have tenant_id via tenant middleware

-- Locations
CREATE TABLE locations (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    code VARCHAR(20) NOT NULL,          -- 'EP', 'NL', or tenant-chosen codes
    name VARCHAR(255) NOT NULL,         -- 'East Passyunk'
    timezone VARCHAR(50) NOT NULL DEFAULT 'America/New_York',
    latitude DECIMAL(9,6) NULL,         -- For weather integration
    longitude DECIMAL(9,6) NULL,
    square_location_id VARCHAR(100) NULL,  -- POS adapter key
    pos_adapter VARCHAR(50) NOT NULL DEFAULT 'square',
    status ENUM('active','inactive') NOT NULL DEFAULT 'active',
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    UNIQUE KEY uq_tenant_code (tenant_id, code)
);

-- Daily actuals (PRIMARY data source — everything else is derived)
CREATE TABLE daily_actuals (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NOT NULL,
    date DATE NOT NULL,
    transactions INT UNSIGNED NOT NULL DEFAULT 0,
    revenue DECIMAL(10,2) NOT NULL DEFAULT 0,
    store_labor DECIMAL(10,2) NOT NULL DEFAULT 0,
    delivery_net DECIMAL(10,2) NOT NULL DEFAULT 0,
    delivery_gross DECIMAL(10,2) NULL,
    delivery_commission DECIMAL(10,2) NULL,
    delivery_source VARCHAR(50) NULL,   -- 'doordash', 'ubereats', etc.
    pos_source VARCHAR(50) NOT NULL DEFAULT 'square',
    synced_at TIMESTAMP NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    UNIQUE KEY uq_tenant_location_date (tenant_id, location_id, date),
    INDEX idx_date (date),
    INDEX idx_month (tenant_id, location_id, date)
);

-- Employees
CREATE TABLE employees (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NULL,   -- NULL = works at multiple locations
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NULL,
    phone VARCHAR(20) NULL,
    pay_rate DECIMAL(8,2) NOT NULL DEFAULT 15.00,
    certifications JSON NULL,           -- ["servsafe_manager", "food_handler"]
    certification_expiry JSON NULL,     -- {"servsafe_manager": "2027-03-15"}
    square_employee_id VARCHAR(100) NULL,
    availability JSON NULL,             -- Weekly availability preferences
    hire_date DATE NULL,
    status ENUM('active','inactive','terminated') NOT NULL DEFAULT 'active',
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    INDEX idx_tenant_location (tenant_id, location_id),
    INDEX idx_square_id (tenant_id, square_employee_id)
);

-- Employee-location pivot (for multi-location employees)
CREATE TABLE employee_locations (
    employee_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NOT NULL,
    PRIMARY KEY (employee_id, location_id)
);

-- Tenant settings (replaces all hardcoded CONFIG values)
CREATE TABLE tenant_settings (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    category VARCHAR(50) NOT NULL,      -- 'pay_rates', 'targets', 'workflow', 'weather', 'seasonal'
    key_name VARCHAR(100) NOT NULL,
    value JSON NOT NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    UNIQUE KEY uq_tenant_category_key (tenant_id, category, key_name)
);
```

### Scheduling Tables

```sql
-- Schedule templates
CREATE TABLE schedule_templates (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NULL,   -- NULL = applies to all locations
    name VARCHAR(255) NOT NULL,
    season VARCHAR(20) NULL,            -- 'winter', 'spring', 'summer', 'fall', NULL = all
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    slots JSON NOT NULL,                -- {Mon: [{start, end, role, headcount}], ...}
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL
);

-- Schedules (week-level container)
CREATE TABLE schedules (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NOT NULL,
    week_start DATE NOT NULL,           -- Monday of the week
    status ENUM('draft','pending','approved','rejected','published') NOT NULL DEFAULT 'draft',
    submitted_at TIMESTAMP NULL,
    reviewed_at TIMESTAMP NULL,
    reviewer_id BIGINT UNSIGNED NULL,
    published_at TIMESTAMP NULL,
    notes TEXT NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    UNIQUE KEY uq_tenant_location_week (tenant_id, location_id, week_start)
);

-- Schedule days
CREATE TABLE schedule_days (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    schedule_id BIGINT UNSIGNED NOT NULL,
    date DATE NOT NULL,
    policy_changed BOOLEAN NOT NULL DEFAULT FALSE,
    pending_request_id BIGINT UNSIGNED NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    UNIQUE KEY uq_schedule_date (schedule_id, date),
    FOREIGN KEY (schedule_id) REFERENCES schedules(id) ON DELETE CASCADE
);

-- Schedule slots (shifts within a day)
CREATE TABLE schedule_slots (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    schedule_day_id BIGINT UNSIGNED NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    role VARCHAR(100) NOT NULL,
    headcount TINYINT UNSIGNED NOT NULL DEFAULT 1,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    FOREIGN KEY (schedule_day_id) REFERENCES schedule_days(id) ON DELETE CASCADE
);

-- Shift assignments (employee to slot)
CREATE TABLE shift_assignments (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    schedule_slot_id BIGINT UNSIGNED NOT NULL,
    employee_id BIGINT UNSIGNED NOT NULL,
    position_index TINYINT UNSIGNED NOT NULL DEFAULT 0,  -- For multi-headcount slots
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    UNIQUE KEY uq_slot_position (schedule_slot_id, position_index),
    FOREIGN KEY (schedule_slot_id) REFERENCES schedule_slots(id) ON DELETE CASCADE,
    FOREIGN KEY (employee_id) REFERENCES employees(id)
);

-- Policy exception requests
CREATE TABLE policy_exception_requests (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    schedule_day_id BIGINT UNSIGNED NOT NULL,
    requester_id BIGINT UNSIGNED NOT NULL,
    reason TEXT NOT NULL,
    status ENUM('pending','approved','denied') NOT NULL DEFAULT 'pending',
    reviewer_id BIGINT UNSIGNED NULL,
    reviewed_at TIMESTAMP NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    FOREIGN KEY (schedule_day_id) REFERENCES schedule_days(id)
);

-- PTO requests
CREATE TABLE pto_requests (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    employee_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NULL,   -- NULL = all locations
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    reason VARCHAR(255) NULL,
    status ENUM('pending','approved','denied') NOT NULL DEFAULT 'pending',
    source VARCHAR(50) NULL,            -- 'square', 'manual', etc.
    synced_at TIMESTAMP NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,
    FOREIGN KEY (employee_id) REFERENCES employees(id)
);
```

### Integration Tables

```sql
-- Delivery syncs (audit log for delivery data imports)
CREATE TABLE delivery_syncs (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NOT NULL,
    source VARCHAR(50) NOT NULL,        -- 'doordash', 'ubereats', etc.
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    rows_total INT UNSIGNED NOT NULL DEFAULT 0,
    rows_applied INT UNSIGNED NOT NULL DEFAULT 0,
    rows_skipped INT UNSIGNED NOT NULL DEFAULT 0,
    net_total DECIMAL(10,2) NOT NULL DEFAULT 0,
    status ENUM('pending','completed','failed') NOT NULL DEFAULT 'pending',
    error_message TEXT NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL
);

-- POS syncs (audit log for POS data imports)
CREATE TABLE pos_syncs (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id BIGINT UNSIGNED NOT NULL,
    location_id BIGINT UNSIGNED NOT NULL,
    adapter VARCHAR(50) NOT NULL,       -- 'square', 'clover', 'toast', etc.
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    transactions_synced INT UNSIGNED NOT NULL DEFAULT 0,
    employees_synced INT UNSIGNED NOT NULL DEFAULT 0,
    status ENUM('pending','completed','failed') NOT NULL DEFAULT 'pending',
    error_message TEXT NULL,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL
);
```

---

## TypeScript Type Definitions

These types define the scheduling engine's data contract — what it receives and returns. The engine is framework-agnostic; these types are consumed by both the Laravel API (via JSON serialization) and the React frontend.

```typescript
// ===== Core Types =====

/** ISO date string: "2025-07-15" */
type ISODate = string;

/** Month key: "2025-07" */
type MonthKey = string;

/** Weekday abbreviation */
type Weekday = 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun';

/** Season name */
type Season = 'winter' | 'spring' | 'summer' | 'fall';

/** Health assessment tone */
type HealthTone = 'good' | 'watch' | 'risk' | 'pending';

/** Weather impact direction */
type WeatherImpact = 'up' | 'down' | 'neutral';

/** Schedule status */
type ScheduleStatus = 'draft' | 'pending' | 'approved' | 'rejected' | 'published';

/** Request status */
type RequestStatus = 'pending' | 'approved' | 'denied';


// ===== Location =====

interface Location {
  id: number;
  code: string;
  name: string;
  timezone: string;
  latitude: number | null;
  longitude: number | null;
  posLocationId: string | null;
  posAdapter: string;
}


// ===== Daily Actuals (primary data source) =====

interface DailyActual {
  date: ISODate;
  locationId: number;
  transactions: number;
  revenue: number;       // POS in-store gross
  storeLabor: number;    // Floor labor cost
  deliveryNet: number;   // Net delivery revenue (after commissions)
  deliveryGross: number | null;
  deliveryCommission: number | null;
  deliverySource: string | null;
}


// ===== Computed Metrics =====

interface DailyMetrics {
  date: ISODate;
  weekday: Weekday;
  revenue: number;
  storeLabor: number;
  deliveryNet: number;
  grossProfit: number;   // revenue * (1 - cogsPct/100) - storeLabor
  laborPct: number;      // storeLabor / revenue * 100
  transactions: number;
}

interface WeekdayProfile {
  weekday: Weekday;
  days: number;          // Sample size
  avgRevenue: number;
  avgLabor: number;
  avgDeliveryNet: number;
  avgGrossProfit: number;
  laborPct: number;
}

interface MonthlyMetrics {
  monthKey: MonthKey;
  operatingDays: number;
  revenue: number;
  storeLabor: number;
  deliveryNet: number;
  grossProfit: number;
  laborPct: number;
  avgDailyRevenue: number;
  avgDailyLabor: number;
}

interface HourlyMetrics {
  hour: number;          // 0-23
  avgRevenue: number;
  avgLabor: number;
  avgDeliveryNet: number;
  avgGrossProfit: number;
}

interface WeeklyMetrics {
  revenue: number;
  labor: number;
  grossProfit: number;
  laborPct: number;
  mondayRevenue: number;
  mondayLabor: number;
  managerAddedLabor: number;
  managerFloorHours: number;
  managerMgmtHours: number;
}

interface AnnualMetrics {
  current: {
    revenue: number;
    labor: number;
    grossProfit: number;
    laborPct: number;
  };
  scenario: {
    revenue: number;
    labor: number;
    grossProfit: number;
    laborPct: number;
    managerAddedLabor: number;
  };
}


// ===== Scheduling =====

interface Slot {
  startTime: string;     // "HH:MM" format
  endTime: string;       // "HH:MM" format
  role: string;
  headcount: number;
  assignments: string[]; // Employee names (indexed by position)
}

interface ScheduleDay {
  date: ISODate;
  slots: Slot[];
  policyChanged: boolean;
  pendingRequestId: number | null;
}

interface Schedule {
  id: number;
  locationId: number;
  weekStart: ISODate;    // Monday
  status: ScheduleStatus;
  days: ScheduleDay[];
  submittedAt: string | null;
  reviewedAt: string | null;
  reviewerId: number | null;
}

interface ScheduleTemplate {
  id: number;
  locationId: number | null;
  name: string;
  season: Season | null;
  isDefault: boolean;
  slots: Record<Weekday, Slot[]>;
}


// ===== Validation & Viability =====

interface DayValidationResult {
  ok: boolean;
  message: string;
}

interface DayFinancialViability {
  tone: HealthTone;
  label: string;
  summary: string;
  expectedRevenue: number;
  expectedLabor: number;
  expectedLaborPct: number;
  plannedLabor: number;
  plannedLaborPct: number;
  expectedGrossProfit: number;
}

interface NextWeekChecks {
  pendingRequests: number;
  unsubmittedPolicyEdits: number;
  unassignedPositions: number;
  invalidCoverageDays: number;
  ptoConflicts: number;
}

interface OverstaffAssessment {
  expectedRevenue: number;
  expectedLabor: number;
  expectedGrossProfit: number;
  expectedLaborPct: number;
  actualLaborPct: number;
  overstaffed: boolean;
  recommendation: string;
  weather: WeatherData | null;
  weatherSignal: WeatherSignal;
}


// ===== Weather =====

interface WeatherData {
  date: ISODate;
  tempMax: number | null;
  tempMin: number | null;
  precipMm: number | null;
  weatherCode: number | null;
  hourlyForecast?: HourlyForecast[];
}

interface HourlyForecast {
  hour: number;
  temp: number;
  precipMm: number;
  weatherCode: number;
}

interface WeatherSignal {
  impact: WeatherImpact;
  label: string;
  reason: string;
  delta: number | null;
  expected: number | null;
  actual: number | null;
  window: string | null;
  eventHour: number | null;
}


// ===== Seasonal Triggers =====

interface TriggerCondition {
  metric: string;
  operator: '>=' | '<=' | '>' | '<' | '==';
  threshold: number;
}

interface SeasonalTriggerRule {
  label: string;
  detail: string;
  conditions: TriggerCondition[];
}

interface TriggerTiming {
  ruleKey: string;
  label: string;
  detail: string;
  firstHit: string;
  lastHit: string;
  hitRate: number;
  currentMet: boolean;
}


// ===== Tenant Settings =====

interface TenantSettings {
  payRates: {
    manager: number;      // Default: 28
    keyLead: number;      // Default: 17
    scooper: number;      // Default: 15
    [role: string]: number;
  };
  managerWeeklyHours: number;     // Default: 40
  cogsPct: number;                // Default: 28 (→ GP margin = 0.72)

  targetProfile: {
    laborTargetPct: number;       // Default: 24
    laborWatchPct: number;        // Default: 27
    profitFloorPct: number;       // Default: 11
    profitBasePct: number;        // Default: 15
    profitStretchPct: number;     // Default: 17
  };

  workflow: {
    minOpeners: number;           // Default: 1
    minClosers: number;           // Default: 2
    requirePolicyApproval: boolean;
    requireGMApproval: boolean;
  };

  weather: {
    thresholdF: number;           // Default: 10 (±10F triggers signal)
    forecastDays: number;         // Default: 16
    normalsYearsBack: number;    // Default: 6
  };

  mondayScenarios: {
    low: number;                  // Default: 0.55
    base: number;                 // Default: 0.65
    high: number;                 // Default: 0.75
  };

  seasonalHours: {
    winter: { open: string; close: string };
    spring: { open: string; close: string };
    summer: { open: string; close: string };
    fall: { open: string; close: string };
  };

  openingSchedule: {
    springUpDate: ISODate;
    summerUpDate: ISODate;
    fallDownDate: ISODate;
    winterDownDate: ISODate;
  };

  revenueMissThreshold: number;   // Default: 0.9 (90%)
  laborPressureDelta: number;     // Default: 3
  repeatAssignmentWeeks: number;  // Default: 12
}


// ===== PTO =====

interface PtoRequest {
  id: number;
  employeeId: number;
  locationId: number | null;  // null = all locations
  startDate: ISODate;
  endDate: ISODate;
  reason: string | null;
  status: RequestStatus;
  source: string | null;      // 'square', 'manual'
}


// ===== Employees =====

interface Employee {
  id: number;
  locationId: number | null;
  name: string;
  email: string | null;
  payRate: number;
  certifications: string[];
  certificationExpiry: Record<string, ISODate>;
  availability: Record<Weekday, { available: boolean; start?: string; end?: string }>;
  status: 'active' | 'inactive' | 'terminated';
}
```

---

## Migration Notes

### What the POS adapter must provide (replaces data.json generation)

The current Python pipeline that generates `data.json` from Square CSV exports is replaced by a **POS adapter** that runs as a Laravel scheduled job:

1. **Daily sync** (via Square API, not CSV):
   - Pull transactions for each location since last sync
   - Aggregate to daily totals: `transactions`, `revenue`, `store_labor`
   - Upsert into `daily_actuals` table

2. **Employee sync**:
   - Pull active team members from Square
   - Upsert into `employees` table with `square_employee_id`

3. **Hourly data** (for hourly profile charts):
   - Pull hourly transaction breakdowns
   - Store in a separate `hourly_actuals` table or as JSON on `daily_actuals`
   - **Open question**: Do we need hour-level data in the DB, or is it sufficient to aggregate on-demand from POS API? Given the charting needs, caching hourly data is recommended.

### What the delivery adapter must provide (replaces DoorDash CSV pipeline)

1. **Periodic sync** (via DoorDash API when available, or CSV upload):
   - Pull order data: date, location, gross revenue, commissions, net revenue
   - Merge into `daily_actuals.delivery_net` (and `delivery_gross`, `delivery_commission`)
   - Log sync audit in `delivery_syncs`

2. **Multi-source support**: A location might have DoorDash + UberEats. Daily actuals should support multiple delivery sources, either as separate rows or aggregated with source tracking.

### Computed vs stored data

| Data | Current | New System | Reason |
|------|---------|------------|--------|
| Monthly aggregates | Pre-computed in JSON | Computed on-demand or cached | Avoid data staleness; trivial to compute from dailies |
| Weekday profiles | Pre-computed in JSON | Computed on-demand | Small dataset (~300 weekdays per location) |
| Hourly profiles | Pre-computed in JSON | Cached from hourly actuals | Hourly data is larger; worth caching |
| Monday scenarios | Pre-computed in JSON | Computed by engine | Pure math from weekday profile |
| Calendar info | Pre-computed in JSON | Computed by engine | Calendar math, no data needed |
| GP / labor % | Pre-computed with hardcoded 0.72 | Computed with tenant COGS% | Tenant-configurable |
| Daily by-date index | Duplicate index in JSON | DB index on date column | Built-in with relational DB |

### Breaking changes from current data model

1. **No more `gross_profit_72`** — All GP calculations use `revenue * (1 - tenant.cogsPct / 100) - labor`
2. **`doordash_net` → `delivery_net`** — POS-agnostic naming
3. **Location codes are DB IDs** — `'EP'` becomes a foreign key to `locations.id`; code is a display property
4. **Employee records are full entities** — Not just string arrays of names
5. **Templates are structured** — JSON slot arrays, not narrative descriptions
6. **All metrics are multi-tenant scoped** — Every query includes `tenant_id`
